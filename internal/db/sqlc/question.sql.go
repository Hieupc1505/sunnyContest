// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: question.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addQuestion = `-- name: AddQuestion :one
INSERT INTO sf_question (
    subject_id, user_id, level, question, question_type, question_image,
    answers, answer_type, state, updated_time
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, now()
         )
RETURNING id, subject_id, user_id, level, question, question_type, question_image, answers, answer_type, state, created_time, updated_time
`

type AddQuestionParams struct {
	SubjectID     int64         `json:"subject_id"`
	UserID        int64         `json:"user_id"`
	Level         LevelQuestion `json:"level"`
	Question      string        `json:"question"`
	QuestionType  string        `json:"question_type"`
	QuestionImage pgtype.Text   `json:"question_image"`
	Answers       string        `json:"answers"`
	AnswerType    string        `json:"answer_type"`
	State         int32         `json:"state"`
}

func (q *Queries) AddQuestion(ctx context.Context, arg AddQuestionParams) (SfQuestion, error) {
	row := q.db.QueryRow(ctx, addQuestion,
		arg.SubjectID,
		arg.UserID,
		arg.Level,
		arg.Question,
		arg.QuestionType,
		arg.QuestionImage,
		arg.Answers,
		arg.AnswerType,
		arg.State,
	)
	var i SfQuestion
	err := row.Scan(
		&i.ID,
		&i.SubjectID,
		&i.UserID,
		&i.Level,
		&i.Question,
		&i.QuestionType,
		&i.QuestionImage,
		&i.Answers,
		&i.AnswerType,
		&i.State,
		&i.CreatedTime,
		&i.UpdatedTime,
	)
	return i, err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM sf_question WHERE id = $1
`

func (q *Queries) DeleteQuestion(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteQuestion, id)
	return err
}

const getQuestionByID = `-- name: GetQuestionByID :one
SELECT id, subject_id, user_id, level, question, question_type, question_image, answers, answer_type, state, created_time, updated_time FROM sf_question WHERE id = $1
`

func (q *Queries) GetQuestionByID(ctx context.Context, id int64) (SfQuestion, error) {
	row := q.db.QueryRow(ctx, getQuestionByID, id)
	var i SfQuestion
	err := row.Scan(
		&i.ID,
		&i.SubjectID,
		&i.UserID,
		&i.Level,
		&i.Question,
		&i.QuestionType,
		&i.QuestionImage,
		&i.Answers,
		&i.AnswerType,
		&i.State,
		&i.CreatedTime,
		&i.UpdatedTime,
	)
	return i, err
}

const getQuestionBySubjectID = `-- name: GetQuestionBySubjectID :many
SELECT id, subject_id, user_id, level, question, question_type, question_image, answers, answer_type, state, created_time, updated_time FROM sf_question WHERE subject_id = $1 ORDER BY created_time DESC LIMIT $2 OFFSET $3
`

type GetQuestionBySubjectIDParams struct {
	SubjectID int64 `json:"subject_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) GetQuestionBySubjectID(ctx context.Context, arg GetQuestionBySubjectIDParams) ([]SfQuestion, error) {
	rows, err := q.db.Query(ctx, getQuestionBySubjectID, arg.SubjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SfQuestion{}
	for rows.Next() {
		var i SfQuestion
		if err := rows.Scan(
			&i.ID,
			&i.SubjectID,
			&i.UserID,
			&i.Level,
			&i.Question,
			&i.QuestionType,
			&i.QuestionImage,
			&i.Answers,
			&i.AnswerType,
			&i.State,
			&i.CreatedTime,
			&i.UpdatedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalQuestion = `-- name: GetTotalQuestion :one
SELECT COUNT(*) FROM sf_question WHERE subject_id = $1
`

func (q *Queries) GetTotalQuestion(ctx context.Context, subjectID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalQuestion, subjectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE sf_question
SET
    subject_id = $2,
    level = $3,
    question = $4,
    question_type = $5,
    question_image = $6,
    answers = $7,
    answer_type = $8,
    user_id = COALESCE(NULLIF($9, 0), user_id),
    state = COALESCE(NULLIF($10, 0), state),
    updated_time = now()
WHERE id = $1
RETURNING id, subject_id, user_id, level, question, question_type, question_image, answers, answer_type, state, created_time, updated_time
`

type UpdateQuestionParams struct {
	ID            int64         `json:"id"`
	SubjectID     int64         `json:"subject_id"`
	Level         LevelQuestion `json:"level"`
	Question      string        `json:"question"`
	QuestionType  string        `json:"question_type"`
	QuestionImage pgtype.Text   `json:"question_image"`
	Answers       string        `json:"answers"`
	AnswerType    string        `json:"answer_type"`
	UserID        interface{}   `json:"user_id"`
	State         interface{}   `json:"state"`
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (SfQuestion, error) {
	row := q.db.QueryRow(ctx, updateQuestion,
		arg.ID,
		arg.SubjectID,
		arg.Level,
		arg.Question,
		arg.QuestionType,
		arg.QuestionImage,
		arg.Answers,
		arg.AnswerType,
		arg.UserID,
		arg.State,
	)
	var i SfQuestion
	err := row.Scan(
		&i.ID,
		&i.SubjectID,
		&i.UserID,
		&i.Level,
		&i.Question,
		&i.QuestionType,
		&i.QuestionImage,
		&i.Answers,
		&i.AnswerType,
		&i.State,
		&i.CreatedTime,
		&i.UpdatedTime,
	)
	return i, err
}
