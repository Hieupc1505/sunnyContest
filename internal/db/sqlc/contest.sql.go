// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: contest.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createContest = `-- name: CreateContest :one
INSERT INTO sf_contest (user_id, subject_id, num_question, time_exam, time_start_exam, state, questions, created_time, updated_time)
VALUES ($1, $2, $3, $4, $5, $6, $7, now(), now())
    RETURNING id, user_id, subject_id, num_question, time_exam, time_start_exam, state, questions, created_time, updated_time
`

type CreateContestParams struct {
	UserID        int64              `json:"user_id"`
	SubjectID     int64              `json:"subject_id"`
	NumQuestion   int32              `json:"num_question"`
	TimeExam      int32              `json:"time_exam"`
	TimeStartExam pgtype.Timestamptz `json:"time_start_exam"`
	State         ContestState       `json:"state"`
	Questions     string             `json:"questions"`
}

func (q *Queries) CreateContest(ctx context.Context, arg CreateContestParams) (SfContest, error) {
	row := q.db.QueryRow(ctx, createContest,
		arg.UserID,
		arg.SubjectID,
		arg.NumQuestion,
		arg.TimeExam,
		arg.TimeStartExam,
		arg.State,
		arg.Questions,
	)
	var i SfContest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubjectID,
		&i.NumQuestion,
		&i.TimeExam,
		&i.TimeStartExam,
		&i.State,
		&i.Questions,
		&i.CreatedTime,
		&i.UpdatedTime,
	)
	return i, err
}

const getContestByID = `-- name: GetContestByID :one
SELECT id, user_id, subject_id, num_question, time_exam, time_start_exam, state, questions, created_time, updated_time FROM sf_contest
WHERE id = $1
`

func (q *Queries) GetContestByID(ctx context.Context, id int64) (SfContest, error) {
	row := q.db.QueryRow(ctx, getContestByID, id)
	var i SfContest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubjectID,
		&i.NumQuestion,
		&i.TimeExam,
		&i.TimeStartExam,
		&i.State,
		&i.Questions,
		&i.CreatedTime,
		&i.UpdatedTime,
	)
	return i, err
}

const getContestBySubjectID = `-- name: GetContestBySubjectID :many
SELECT id, user_id, subject_id, num_question, time_exam, time_start_exam, state, questions, created_time, updated_time FROM sf_contest
WHERE subject_id = $1
`

func (q *Queries) GetContestBySubjectID(ctx context.Context, subjectID int64) ([]SfContest, error) {
	rows, err := q.db.Query(ctx, getContestBySubjectID, subjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SfContest{}
	for rows.Next() {
		var i SfContest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SubjectID,
			&i.NumQuestion,
			&i.TimeExam,
			&i.TimeStartExam,
			&i.State,
			&i.Questions,
			&i.CreatedTime,
			&i.UpdatedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContestDetailByID = `-- name: GetContestDetailByID :one
SELECT c.id, c.time_exam, c.num_question, c.state, c.user_id, c.questions, c.subject_id, s.name AS subject_name  FROM sf_contest c
JOIN sf_subject s ON c.subject_id = s.id
WHERE c.id = $1
`

type GetContestDetailByIDRow struct {
	ID          int64        `json:"id"`
	TimeExam    int32        `json:"time_exam"`
	NumQuestion int32        `json:"num_question"`
	State       ContestState `json:"state"`
	UserID      int64        `json:"user_id"`
	Questions   string       `json:"questions"`
	SubjectID   int64        `json:"subject_id"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetContestDetailByID(ctx context.Context, id int64) (GetContestDetailByIDRow, error) {
	row := q.db.QueryRow(ctx, getContestDetailByID, id)
	var i GetContestDetailByIDRow
	err := row.Scan(
		&i.ID,
		&i.TimeExam,
		&i.NumQuestion,
		&i.State,
		&i.UserID,
		&i.Questions,
		&i.SubjectID,
		&i.SubjectName,
	)
	return i, err
}

const getContestLiveByID = `-- name: GetContestLiveByID :one
SELECT c.id, c.time_exam, c.num_question, c.state, c.user_id, c.questions, c.subject_id, s.name AS subject_name  FROM sf_contest c
JOIN sf_subject s ON c.subject_id = s.id
WHERE c.id = $1 AND c.state IN ('IDLE', 'RUNNING', 'WAITING')
`

type GetContestLiveByIDRow struct {
	ID          int64        `json:"id"`
	TimeExam    int32        `json:"time_exam"`
	NumQuestion int32        `json:"num_question"`
	State       ContestState `json:"state"`
	UserID      int64        `json:"user_id"`
	Questions   string       `json:"questions"`
	SubjectID   int64        `json:"subject_id"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetContestLiveByID(ctx context.Context, id int64) (GetContestLiveByIDRow, error) {
	row := q.db.QueryRow(ctx, getContestLiveByID, id)
	var i GetContestLiveByIDRow
	err := row.Scan(
		&i.ID,
		&i.TimeExam,
		&i.NumQuestion,
		&i.State,
		&i.UserID,
		&i.Questions,
		&i.SubjectID,
		&i.SubjectName,
	)
	return i, err
}

const getContestsForTeacher = `-- name: GetContestsForTeacher :many
SELECT c.id, c.time_exam, c.num_question, c.state, c.user_id, c.questions, c.subject_id, s.name AS subject_name
FROM sf_contest c
JOIN sf_subject s ON c.subject_id = s.id
WHERE c.user_id = $1
ORDER BY c.created_time
DESC LIMIT $2 OFFSET $3
`

type GetContestsForTeacherParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetContestsForTeacherRow struct {
	ID          int64        `json:"id"`
	TimeExam    int32        `json:"time_exam"`
	NumQuestion int32        `json:"num_question"`
	State       ContestState `json:"state"`
	UserID      int64        `json:"user_id"`
	Questions   string       `json:"questions"`
	SubjectID   int64        `json:"subject_id"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetContestsForTeacher(ctx context.Context, arg GetContestsForTeacherParams) ([]GetContestsForTeacherRow, error) {
	rows, err := q.db.Query(ctx, getContestsForTeacher, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContestsForTeacherRow{}
	for rows.Next() {
		var i GetContestsForTeacherRow
		if err := rows.Scan(
			&i.ID,
			&i.TimeExam,
			&i.NumQuestion,
			&i.State,
			&i.UserID,
			&i.Questions,
			&i.SubjectID,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListLiveContest = `-- name: GetListLiveContest :many
SELECT c.id, c.time_exam, c.num_question, c.state, s.name AS subject_name  FROM sf_contest c
JOIN sf_subject s ON c.subject_id = s.id
WHERE c.state IN ('RUNNING', 'WAITING')
`

type GetListLiveContestRow struct {
	ID          int64        `json:"id"`
	TimeExam    int32        `json:"time_exam"`
	NumQuestion int32        `json:"num_question"`
	State       ContestState `json:"state"`
	SubjectName string       `json:"subject_name"`
}

func (q *Queries) GetListLiveContest(ctx context.Context) ([]GetListLiveContestRow, error) {
	rows, err := q.db.Query(ctx, getListLiveContest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetListLiveContestRow{}
	for rows.Next() {
		var i GetListLiveContestRow
		if err := rows.Scan(
			&i.ID,
			&i.TimeExam,
			&i.NumQuestion,
			&i.State,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyContestLive = `-- name: GetMyContestLive :one
SELECT c.id, c.user_id, c.subject_id, c.num_question, c.time_exam, c.time_start_exam, c.state, c.questions, c.created_time, c.updated_time, s.name AS subject_name
FROM sf_contest c
JOIN sf_subject s ON c.subject_id = s.id
WHERE c.user_id = $1 AND c.state IN ('IDLE', 'RUNNING', 'WAITING')
`

type GetMyContestLiveRow struct {
	ID            int64              `json:"id"`
	UserID        int64              `json:"user_id"`
	SubjectID     int64              `json:"subject_id"`
	NumQuestion   int32              `json:"num_question"`
	TimeExam      int32              `json:"time_exam"`
	TimeStartExam pgtype.Timestamptz `json:"time_start_exam"`
	State         ContestState       `json:"state"`
	Questions     string             `json:"questions"`
	CreatedTime   time.Time          `json:"created_time"`
	UpdatedTime   time.Time          `json:"updated_time"`
	SubjectName   string             `json:"subject_name"`
}

func (q *Queries) GetMyContestLive(ctx context.Context, userID int64) (GetMyContestLiveRow, error) {
	row := q.db.QueryRow(ctx, getMyContestLive, userID)
	var i GetMyContestLiveRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubjectID,
		&i.NumQuestion,
		&i.TimeExam,
		&i.TimeStartExam,
		&i.State,
		&i.Questions,
		&i.CreatedTime,
		&i.UpdatedTime,
		&i.SubjectName,
	)
	return i, err
}

const getRandomQuestions = `-- name: GetRandomQuestions :many
SELECT id, subject_id, user_id, level, question, question_type, question_image, answers, answer_type, state, created_time, updated_time
FROM sf_question
WHERE subject_id = $1
ORDER BY random()
LIMIT $2
`

type GetRandomQuestionsParams struct {
	SubjectID int64 `json:"subject_id"`
	Limit     int32 `json:"limit"`
}

func (q *Queries) GetRandomQuestions(ctx context.Context, arg GetRandomQuestionsParams) ([]SfQuestion, error) {
	rows, err := q.db.Query(ctx, getRandomQuestions, arg.SubjectID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SfQuestion{}
	for rows.Next() {
		var i SfQuestion
		if err := rows.Scan(
			&i.ID,
			&i.SubjectID,
			&i.UserID,
			&i.Level,
			&i.Question,
			&i.QuestionType,
			&i.QuestionImage,
			&i.Answers,
			&i.AnswerType,
			&i.State,
			&i.CreatedTime,
			&i.UpdatedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startContest = `-- name: StartContest :exec
UPDATE sf_contest
SET state = 'RUNNING', time_start_exam = now()
WHERE id = $1
`

func (q *Queries) StartContest(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, startContest, id)
	return err
}

const stopContest = `-- name: StopContest :exec
UPDATE sf_contest
SET state = 'FINISHED'
WHERE id = $1
`

func (q *Queries) StopContest(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, stopContest, id)
	return err
}

const updateContest = `-- name: UpdateContest :one
UPDATE sf_contest
SET user_id = $2, subject_id = $3, num_question = $4, time_exam = $5, time_start_exam = $6, state = $7, questions = $8, updated_time = now()
WHERE id = $1
RETURNING id, user_id, subject_id, num_question, time_exam, time_start_exam, state, questions, created_time, updated_time
`

type UpdateContestParams struct {
	ID            int64              `json:"id"`
	UserID        int64              `json:"user_id"`
	SubjectID     int64              `json:"subject_id"`
	NumQuestion   int32              `json:"num_question"`
	TimeExam      int32              `json:"time_exam"`
	TimeStartExam pgtype.Timestamptz `json:"time_start_exam"`
	State         ContestState       `json:"state"`
	Questions     string             `json:"questions"`
}

func (q *Queries) UpdateContest(ctx context.Context, arg UpdateContestParams) (SfContest, error) {
	row := q.db.QueryRow(ctx, updateContest,
		arg.ID,
		arg.UserID,
		arg.SubjectID,
		arg.NumQuestion,
		arg.TimeExam,
		arg.TimeStartExam,
		arg.State,
		arg.Questions,
	)
	var i SfContest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubjectID,
		&i.NumQuestion,
		&i.TimeExam,
		&i.TimeStartExam,
		&i.State,
		&i.Questions,
		&i.CreatedTime,
		&i.UpdatedTime,
	)
	return i, err
}

const updateContestQuestions = `-- name: UpdateContestQuestions :exec
UPDATE sf_contest
SET questions = $2
WHERE id = $1
`

type UpdateContestQuestionsParams struct {
	ID        int64  `json:"id"`
	Questions string `json:"questions"`
}

func (q *Queries) UpdateContestQuestions(ctx context.Context, arg UpdateContestQuestionsParams) error {
	_, err := q.db.Exec(ctx, updateContestQuestions, arg.ID, arg.Questions)
	return err
}

const updateContestStateAndQuestions = `-- name: UpdateContestStateAndQuestions :exec
UPDATE sf_contest
SET state = $2, questions = $3, updated_time = now()
WHERE id = $1
`

type UpdateContestStateAndQuestionsParams struct {
	ID        int64        `json:"id"`
	State     ContestState `json:"state"`
	Questions string       `json:"questions"`
}

func (q *Queries) UpdateContestStateAndQuestions(ctx context.Context, arg UpdateContestStateAndQuestionsParams) error {
	_, err := q.db.Exec(ctx, updateContestStateAndQuestions, arg.ID, arg.State, arg.Questions)
	return err
}

const updateStateContest = `-- name: UpdateStateContest :exec
UPDATE sf_contest
SET state = $2, updated_time = now()
WHERE id = $1
`

type UpdateStateContestParams struct {
	ID    int64        `json:"id"`
	State ContestState `json:"state"`
}

func (q *Queries) UpdateStateContest(ctx context.Context, arg UpdateStateContestParams) error {
	_, err := q.db.Exec(ctx, updateStateContest, arg.ID, arg.State)
	return err
}
