// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user_contest.sql

package db

import (
	"context"
	"encoding/json"
	"time"
)

const addUserContest = `-- name: AddUserContest :one
INSERT INTO sf_user_contest (contest_id, user_id, questions)
VALUES (
   $1, -- contest_id
   $2, -- user_id
   $3 -- questions (JSONB)
)
RETURNING id, contest_id, user_id, questions, exam, result, created_time, updated_time
`

type AddUserContestParams struct {
	ContestID int64           `json:"contest_id"`
	UserID    int64           `json:"user_id"`
	Questions json.RawMessage `json:"questions"`
}

func (q *Queries) AddUserContest(ctx context.Context, arg AddUserContestParams) (SfUserContest, error) {
	row := q.db.QueryRow(ctx, addUserContest, arg.ContestID, arg.UserID, arg.Questions)
	var i SfUserContest
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.Questions,
		&i.Exam,
		&i.Result,
		&i.CreatedTime,
		&i.UpdatedTime,
	)
	return i, err
}

const getUserContest = `-- name: GetUserContest :one
SELECT id, contest_id, user_id, questions, exam, result, created_time, updated_time
FROM sf_user_contest
WHERE contest_id = $1 AND user_id = $2
`

type GetUserContestParams struct {
	ContestID int64 `json:"contest_id"`
	UserID    int64 `json:"user_id"`
}

func (q *Queries) GetUserContest(ctx context.Context, arg GetUserContestParams) (SfUserContest, error) {
	row := q.db.QueryRow(ctx, getUserContest, arg.ContestID, arg.UserID)
	var i SfUserContest
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.Questions,
		&i.Exam,
		&i.Result,
		&i.CreatedTime,
		&i.UpdatedTime,
	)
	return i, err
}

const getUserContestsByContestID = `-- name: GetUserContestsByContestID :many
SELECT
    s.id,
    s.contest_id,
    s.user_id,
    s.questions,
    s.exam,
    s.result,
    s.created_time,
    s.updated_time,
    p.nickname  -- Lấy nickname từ bảng sf_profile
FROM sf_user_contest s
JOIN sf_profile p ON s.user_id = p.user_id  -- Kết nối bảng sf_user_contest với bảng sf_profile qua user_id
WHERE s.contest_id = $1
`

type GetUserContestsByContestIDRow struct {
	ID          int64           `json:"id"`
	ContestID   int64           `json:"contest_id"`
	UserID      int64           `json:"user_id"`
	Questions   json.RawMessage `json:"questions"`
	Exam        []byte          `json:"exam"`
	Result      []byte          `json:"result"`
	CreatedTime time.Time       `json:"created_time"`
	UpdatedTime time.Time       `json:"updated_time"`
	Nickname    string          `json:"nickname"`
}

func (q *Queries) GetUserContestsByContestID(ctx context.Context, contestID int64) ([]GetUserContestsByContestIDRow, error) {
	rows, err := q.db.Query(ctx, getUserContestsByContestID, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserContestsByContestIDRow{}
	for rows.Next() {
		var i GetUserContestsByContestIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ContestID,
			&i.UserID,
			&i.Questions,
			&i.Exam,
			&i.Result,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.Nickname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserContestsJoined = `-- name: GetUserContestsJoined :many
SELECT
    c.id,
    c.time_exam,
    c.num_question,
    s.name AS subject_name
FROM
    sf_user_contest uc
        JOIN
    sf_contest c ON uc.contest_id = c.id
        JOIN
    sf_subject s ON c.subject_id = s.id
WHERE
    uc.user_id = $1
`

type GetUserContestsJoinedRow struct {
	ID          int64  `json:"id"`
	TimeExam    int32  `json:"time_exam"`
	NumQuestion int32  `json:"num_question"`
	SubjectName string `json:"subject_name"`
}

func (q *Queries) GetUserContestsJoined(ctx context.Context, userID int64) ([]GetUserContestsJoinedRow, error) {
	rows, err := q.db.Query(ctx, getUserContestsJoined, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserContestsJoinedRow{}
	for rows.Next() {
		var i GetUserContestsJoinedRow
		if err := rows.Scan(
			&i.ID,
			&i.TimeExam,
			&i.NumQuestion,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersInContest = `-- name: GetUsersInContest :many
SELECT c.id, c.contest_id, c.user_id, c.questions, c.exam, c.result, c.created_time, c.updated_time, s.nickname, s.avatar FROM sf_user_contest c
JOIN sf_profile s ON c.user_id = s.user_id
WHERE c.contest_id = $1
`

type GetUsersInContestRow struct {
	ID          int64           `json:"id"`
	ContestID   int64           `json:"contest_id"`
	UserID      int64           `json:"user_id"`
	Questions   json.RawMessage `json:"questions"`
	Exam        []byte          `json:"exam"`
	Result      []byte          `json:"result"`
	CreatedTime time.Time       `json:"created_time"`
	UpdatedTime time.Time       `json:"updated_time"`
	Nickname    string          `json:"nickname"`
	Avatar      string          `json:"avatar"`
}

func (q *Queries) GetUsersInContest(ctx context.Context, contestID int64) ([]GetUsersInContestRow, error) {
	rows, err := q.db.Query(ctx, getUsersInContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersInContestRow{}
	for rows.Next() {
		var i GetUsersInContestRow
		if err := rows.Scan(
			&i.ID,
			&i.ContestID,
			&i.UserID,
			&i.Questions,
			&i.Exam,
			&i.Result,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.Nickname,
			&i.Avatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExamAndResult = `-- name: UpdateExamAndResult :exec
UPDATE sf_user_contest
SET exam = $3::jsonb,
    result = $4::jsonb,
    updated_time = now()
WHERE contest_id = $1 AND user_id = $2
`

type UpdateExamAndResultParams struct {
	ContestID int64           `json:"contest_id"`
	UserID    int64           `json:"user_id"`
	Exam      json.RawMessage `json:"exam"`
	Result    json.RawMessage `json:"result"`
}

func (q *Queries) UpdateExamAndResult(ctx context.Context, arg UpdateExamAndResultParams) error {
	_, err := q.db.Exec(ctx, updateExamAndResult,
		arg.ContestID,
		arg.UserID,
		arg.Exam,
		arg.Result,
	)
	return err
}
